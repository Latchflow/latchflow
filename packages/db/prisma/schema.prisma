// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

///////////////////////////
// ENUMS
///////////////////////////

enum UserRole {
  ADMIN
  EXECUTOR
  RECIPIENT
}

enum CapabilityKind {
  TRIGGER
  ACTION
}

enum InvocationStatus {
  PENDING
  SUCCESS
  FAILED
  SKIPPED_DISABLED
}

enum VerificationType {
  MAGIC_LINK
  OTP
  PASSPHRASE
}

enum PermissionType {
  DOWNLOAD_ACCESS
  SEND_MESSAGE
  ADMIN_PANEL
  OVERRIDE_RELEASE
}

// Provenance enums for ChangeLog
enum ActorType {
  USER
  ACTION
  SYSTEM
}

enum ChangeKind {
  ADD_CHILD
  UPDATE_CHILD
  REMOVE_CHILD
  REORDER
  UPDATE_PARENT
}

///////////////////////////
// CORE MODELS
///////////////////////////

model User {
  id                  String               @id @default(uuid())
  email               String               @unique
  name                String?
  isActive            Boolean              @default(true)
  deactivatedAt       DateTime?
  roles               UserRole[]
  executorAssignments ExecutorAssignment[]
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  actionInvocations   ActionInvocation[]
  sessions            Session[]
  magicLinks          MagicLink[]
  apiTokens           ApiToken[]
  deviceAuths         DeviceAuth[]

  // Back-relations for creator/updater across models
  createdRecipients        Recipient[]         @relation("createdRecipients")
  updatedRecipients        Recipient[]         @relation("updatedRecipients")
  createdFiles             File[]              @relation("createdFiles")
  updatedFiles             File[]              @relation("updatedFiles")
  createdBundles           Bundle[]            @relation("createdBundles")
  updatedBundles           Bundle[]            @relation("updatedBundles")
  createdBundleObjects     BundleObject[]      @relation("createdBundleObjects")
  updatedBundleObjects     BundleObject[]      @relation("updatedBundleObjects")
  createdBundleAssignments BundleAssignment[]  @relation("createdBundleAssignments")
  updatedBundleAssignments BundleAssignment[]  @relation("updatedBundleAssignments")
  createdTriggers          TriggerDefinition[] @relation("createdTriggers")
  updatedTriggers          TriggerDefinition[] @relation("updatedTriggers")
  createdActions           ActionDefinition[]  @relation("createdActions")
  updatedActions           ActionDefinition[]  @relation("updatedActions")
  createdPipelines         Pipeline[]          @relation("createdPipelines")
  updatedPipelines         Pipeline[]          @relation("updatedPipelines")
  createdPipelineSteps     PipelineStep[]      @relation("createdPipelineSteps")
  updatedPipelineSteps     PipelineStep[]      @relation("updatedPipelineSteps")
  createdPipelineTriggers  PipelineTrigger[]   @relation("createdPipelineTriggers")
  updatedPipelineTriggers  PipelineTrigger[]   @relation("updatedPipelineTriggers")

  // Back-relations for ChangeLog provenance
  changeLogsAsActorUser ChangeLog[] @relation("ChangeLogActorUser")
  changeLogsOnBehalfOf  ChangeLog[] @relation("ChangeLogOnBehalfUser")

  @@index([isActive])
}

model Recipient {
  id                String             @id @default(uuid())
  email             String             @unique
  name              String?
  bundleAssignments BundleAssignment[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  createdBy         String
  updatedBy         String?

  creator User  @relation("createdRecipients", fields: [createdBy], references: [id])
  updater User? @relation("updatedRecipients", fields: [updatedBy], references: [id])
}

model File {
  id          String   @id @default(uuid())
  // Logical name/path in the admin UI (can be moved/renamed)
  key         String   @unique
  // Where the blob actually lives in storage (content-addressed path or provider key)
  storageKey  String   @unique
  contentHash String // e.g., sha256 hex (useful for ETag/dedup)
  size        BigInt
  contentType String
  metadata    Json?
  version     Int      @default(1)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String
  updatedBy   String?
  creator     User     @relation("createdFiles", fields: [createdBy], references: [id])
  updater     User?    @relation("updatedFiles", fields: [updatedBy], references: [id])

  bundleObjects  BundleObject[]
  downloadEvents DownloadEvent[]

  @@index([contentHash, size])
  @@index([updatedAt])
}

model Bundle {
  id            String             @id @default(uuid())
  name          String
  storagePath   String
  checksum      String
  description   String?
  bundleObjects BundleObject[]
  assignments   BundleAssignment[]
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  createdBy     String
  updatedBy     String?

  creator             User                 @relation("createdBundles", fields: [createdBy], references: [id])
  updater             User?                @relation("updatedBundles", fields: [updatedBy], references: [id])
  executorAssignments ExecutorAssignment[]
}

model BundleObject {
  id        String  @id @default(uuid())
  bundleId  String
  fileId    String
  path      String?
  sortOrder Int     @default(0)
  required  Boolean @default(false)
  notes     String?

  addedAt   DateTime @default(now())
  createdBy String
  updatedBy String?

  creator User   @relation("createdBundleObjects", fields: [createdBy], references: [id])
  updater User?  @relation("updatedBundleObjects", fields: [updatedBy], references: [id])
  file    File   @relation(fields: [fileId], references: [id], onDelete: Restrict)
  bundle  Bundle @relation(fields: [bundleId], references: [id], onDelete: Cascade)

  @@unique([bundleId, fileId]) // a file appears at most once per bundle (adjust if you want duplicates)
  @@index([bundleId, sortOrder])
}

model BundleAssignment {
  id               String            @id @default(uuid())
  bundleId         String
  recipientId      String
  maxDownloads     Int?
  cooldownSeconds  Int?
  verificationType VerificationType?
  verificationMet  Boolean           @default(false)
  lastDownloadAt   DateTime?
  downloadEvents   DownloadEvent[]
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  createdBy        String
  updatedBy        String?

  creator   User      @relation("createdBundleAssignments", fields: [createdBy], references: [id])
  updater   User?     @relation("updatedBundleAssignments", fields: [updatedBy], references: [id])
  recipient Recipient @relation(fields: [recipientId], references: [id])
  bundle    Bundle    @relation(fields: [bundleId], references: [id])
}

model DownloadEvent {
  id                 String           @id @default(uuid())
  bundleAssignment   BundleAssignment @relation(fields: [bundleAssignmentId], references: [id])
  bundleAssignmentId String
  triggerEvent       TriggerEvent?    @relation(fields: [triggerEventId], references: [id])
  triggerEventId     String?
  downloadedAt       DateTime         @default(now())
  userAgent          String
  ip                 String
  file               File?            @relation(fields: [fileId], references: [id])
  fileId             String?
}

///////////////////////////
// PLUGIN REGISTRY
///////////////////////////

model Plugin {
  id            String             @id @default(uuid())
  name          String
  version       String?
  description   String?
  author        String?
  homepageUrl   String?
  repositoryUrl String?
  installedAt   DateTime           @default(now())
  capabilities  PluginCapability[]
}

model PluginCapability {
  id          String              @id @default(uuid())
  plugin      Plugin              @relation(fields: [pluginId], references: [id])
  pluginId    String
  kind        CapabilityKind
  key         String // e.g. "cron_schedule", "email_notify"
  displayName String
  jsonSchema  Json?
  isEnabled   Boolean             @default(true)
  createdAt   DateTime            @default(now())
  triggers    TriggerDefinition[]
  actions     ActionDefinition[]

  @@unique([pluginId, key])
}

///////////////////////////
// TRIGGERS & ACTIONS
///////////////////////////

model TriggerDefinition {
  id                  String               @id @default(uuid())
  name                String
  capabilityId        String
  config              Json
  executorAssignments ExecutorAssignment[]
  ExecutorPermission  ExecutorPermission[]
  pipelines           PipelineTrigger[]
  events              TriggerEvent[]
  isEnabled           Boolean              @default(true)
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  createdBy           String
  updatedBy           String?

  creator    User             @relation("createdTriggers", fields: [createdBy], references: [id])
  updater    User?            @relation("updatedTriggers", fields: [updatedBy], references: [id])
  capability PluginCapability @relation(fields: [capabilityId], references: [id])
}

model TriggerEvent {
  id                  String             @id @default(uuid())
  triggerDefinition   TriggerDefinition  @relation(fields: [triggerDefinitionId], references: [id])
  triggerDefinitionId String
  firedAt             DateTime           @default(now())
  context             Json
  actionInvocations   ActionInvocation[]
  downloadEvents      DownloadEvent[]
  pipelineRuns        PipelineRun[]
}

model ActionDefinition {
  id                String             @id @default(uuid())
  name              String
  capabilityId      String
  config            Json
  isEnabled         Boolean            @default(true)
  pipelineSteps     PipelineStep[]
  actionInvocations ActionInvocation[]
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  createdBy         String
  updatedBy         String?

  creator    User             @relation("createdActions", fields: [createdBy], references: [id])
  updater    User?            @relation("updatedActions", fields: [updatedBy], references: [id])
  capability PluginCapability @relation(fields: [capabilityId], references: [id])

  // Back-relation for ChangeLog provenance
  changeLogs ChangeLog[]
}

model ActionInvocation {
  id                 String           @id @default(uuid())
  actionDefinition   ActionDefinition @relation(fields: [actionDefinitionId], references: [id])
  actionDefinitionId String
  triggerEvent       TriggerEvent?    @relation(fields: [triggerEventId], references: [id])
  triggerEventId     String?
  manualInvoker      User?            @relation(fields: [manualInvokerId], references: [id])
  manualInvokerId    String?
  status             InvocationStatus
  startedAt          DateTime         @default(now())
  completedAt        DateTime?
  result             Json?

  // Optional linkage to pipeline orchestration
  pipelineStep   PipelineStep? @relation(fields: [pipelineStepId], references: [id])
  pipelineStepId String?
  pipeline       Pipeline?     @relation(fields: [pipelineId], references: [id])
  pipelineId     String?
  stepIndex      Int?

  // Optional grouping of invocations belonging to a specific pipeline execution
  pipelineRun   PipelineRun? @relation(fields: [pipelineRunId], references: [id])
  pipelineRunId String?

  // Back-relation for ChangeLog provenance
  changeLogs ChangeLog[]

  @@index([triggerEventId, pipelineId, startedAt])
  @@index([pipelineStepId, startedAt])
}

// Append-only history for aggregate roots and independent roots
model ChangeLog {
  id         String  @id @default(uuid())
  entityType String
  entityId   String
  version    Int
  isSnapshot Boolean
  state      Json?
  diff       Json?
  hash       String

  actorType   ActorType
  actorUserId String?
  actorUser   User?     @relation("ChangeLogActorUser", fields: [actorUserId], references: [id])

  actorInvocationId String?
  actorInvocation   ActionInvocation? @relation(fields: [actorInvocationId], references: [id])

  actorActionDefinitionId String?
  actorActionDefinition   ActionDefinition? @relation(fields: [actorActionDefinitionId], references: [id])

  onBehalfOfUserId String?
  onBehalfOfUser   User?   @relation("ChangeLogOnBehalfUser", fields: [onBehalfOfUserId], references: [id])

  changeNote  String?
  changedPath String?
  changeKind  ChangeKind?

  createdAt DateTime @default(now())

  @@unique([entityType, entityId, version])
  @@index([entityType, entityId, isSnapshot])
  @@index([entityType, entityId, isSnapshot, version])
  @@index([createdAt])
  @@index([actorType])
  @@index([actorUserId, createdAt])
  @@index([actorActionDefinitionId, createdAt])
}

///////////////////////////
// Piplines & Steps
///////////////////////////

model Pipeline {
  id          String            @id @default(uuid())
  name        String
  description String?
  isEnabled   Boolean           @default(true)
  steps       PipelineStep[]
  triggers    PipelineTrigger[]
  // Back-relation: pipeline runs
  runs        PipelineRun[]
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  createdBy   String
  updatedBy   String?

  creator           User               @relation("createdPipelines", fields: [createdBy], references: [id])
  updater           User?              @relation("updatedPipelines", fields: [updatedBy], references: [id])
  actionInvocations ActionInvocation[]
}

model PipelineStep {
  id         String   @id @default(uuid())
  pipelineId String
  actionId   String
  sortOrder  Int      @default(0)
  isEnabled  Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  createdBy  String
  updatedBy  String?

  creator                User               @relation("createdPipelineSteps", fields: [createdBy], references: [id])
  updater                User?              @relation("updatedPipelineSteps", fields: [updatedBy], references: [id])
  pipeline               Pipeline           @relation(fields: [pipelineId], references: [id])
  action                 ActionDefinition   @relation(fields: [actionId], references: [id])
  actionInvocations      ActionInvocation[]

  @@unique([pipelineId, sortOrder], map: "pipelinestep_sort_unique")
}

model PipelineTrigger {
  pipelineId String
  triggerId  String
  sortOrder  Int      @default(0)
  isEnabled  Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  createdBy  String
  updatedBy  String?

  creator  User              @relation("createdPipelineTriggers", fields: [createdBy], references: [id])
  updater  User?             @relation("updatedPipelineTriggers", fields: [updatedBy], references: [id])
  pipeline Pipeline          @relation(fields: [pipelineId], references: [id])
  trigger  TriggerDefinition @relation(fields: [triggerId], references: [id])

  @@id([pipelineId, triggerId])
  @@unique([triggerId, sortOrder], map: "pipelinetrigger_sort_unique")
}

///////////////////////////
// Pipeline Runs
///////////////////////////

model PipelineRun {
  id             String           @id @default(uuid())
  triggerEvent   TriggerEvent?    @relation(fields: [triggerEventId], references: [id])
  triggerEventId String?
  pipeline       Pipeline         @relation(fields: [pipelineId], references: [id])
  pipelineId     String
  status         InvocationStatus
  startedAt      DateTime         @default(now())
  completedAt    DateTime?
  result         Json?

  // Back-relation to the step executions comprising this run
  actionInvocations ActionInvocation[]

  @@index([triggerEventId, pipelineId, startedAt])
}

///////////////////////////
// EXECUTOR PERMISSIONS
///////////////////////////

model ExecutorAssignment {
  id                  String               @id @default(uuid())
  executor            User                 @relation(fields: [executorId], references: [id])
  executorId          String
  bundle              Bundle?              @relation(fields: [bundleId], references: [id])
  bundleId            String?
  triggerDefinition   TriggerDefinition?   @relation(fields: [triggerDefinitionId], references: [id])
  triggerDefinitionId String?
  permissions         ExecutorPermission[]
}

model ExecutorPermission {
  id                      String             @id @default(uuid())
  assignment              ExecutorAssignment @relation(fields: [assignmentId], references: [id])
  assignmentId            String
  type                    PermissionType
  isActive                Boolean            @default(true)
  activatedAfterTrigger   TriggerDefinition? @relation(fields: [activatedAfterTriggerId], references: [id])
  activatedAfterTriggerId String?
}

///////////////////////////
// AUTH MODELS
///////////////////////////

model Session {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  jti       String    @unique
  createdAt DateTime  @default(now())
  expiresAt DateTime
  revokedAt DateTime?
  ip        String?
  userAgent String?

  @@index([userId, expiresAt])
}

model MagicLink {
  id         String    @id @default(uuid())
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash  String    @unique
  createdAt  DateTime  @default(now())
  expiresAt  DateTime
  consumedAt DateTime?
}

model RecipientSession {
  id          String    @id @default(uuid())
  recipientId String
  bundleId    String
  jti         String    @unique
  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  revokedAt   DateTime?
  ip          String?
  userAgent   String?

  @@index([recipientId, bundleId])
}

model RecipientOtp {
  id          String   @id @default(uuid())
  recipientId String
  bundleId    String
  codeHash    String
  createdAt   DateTime @default(now())
  expiresAt   DateTime
  attempts    Int      @default(0)

  @@index([recipientId, bundleId])
}

///////////////////////////
// CLI AUTH MODELS
///////////////////////////

model ApiToken {
  id          String       @id @default(uuid())
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  scopes      String[]
  tokenHash   String       @unique
  createdAt   DateTime     @default(now())
  lastUsedAt  DateTime?
  expiresAt   DateTime?
  revokedAt   DateTime?
  deviceAuths DeviceAuth[]

  @@index([userId])
}

model DeviceAuth {
  id             String    @id @default(uuid())
  userId         String?
  user           User?     @relation(fields: [userId], references: [id], onDelete: Cascade)
  email          String
  deviceName     String?
  deviceCodeHash String    @unique
  userCodeHash   String    @unique
  intervalSec    Int       @default(5)
  createdAt      DateTime  @default(now())
  expiresAt      DateTime
  approvedAt     DateTime?
  tokenId        String?
  token          ApiToken? @relation(fields: [tokenId], references: [id], onDelete: SetNull)
}
